реализация на с++
#include <iostream>
#include <vector>
#include <limits>
#include <algorithm>
using namespace std;

const int INF = numeric_limits<int>::max();

int tsp(vector<vector<int>>& dist, int pos, int visited, vector<vector<int>>& dp) {
    int n = dist.size();
    if (visited == (1 << n) - 1)
        return dist[pos][0];

    if (dp[pos][visited] != -1)
        return dp[pos][visited];

    int ans = INF;
    for (int city = 0; city < n; city++) {
        if ((visited & (1 << city)) == 0 && dist[pos][city] != INF) {
            int newCost = dist[pos][city] + tsp(dist, city, visited | (1 << city), dp);
            ans = min(ans, newCost);
        }
    }
    return dp[pos][visited] = ans;
}

int main() {
    vector<vector<int>> dist = {
        {INF, 10, 15, 20},
        {10, INF, 35, 25},
        {15, 35, INF, 30},
        {20, 25, 30, INF}
    };

    int n = dist.size();
    vector<vector<int>> dp(n, vector<int>((1 << n), -1));
    cout << "Минимальное расстояние: " << tsp(dist, 0, 1, dp) << endl;
    return 0;
}

объяснение реализации задачи коммивояжера на C++

В коде решается задача коммивояжера с помощью динамического программирования и битовых масок.

1. Исходные данные и константы

const int INF = numeric_limits<int>::max();
- `INF — значение, используемое как "бесконечность" для недостижимых путей.

``cpp
vector<vector<int>> dist = {
    {INF, 10, 15, 20},
    {10, INF, 35, 25},
    {15, 35, INF, 30},
    {20, 25, 30, INF}
};
- `dist` — матрица расстояний между 4-мя городами.
- Элемент `dist[i][j]` — расстояние от города `i` до города `j`.
- `INF` на диагонали, так как дорога из города в себя не учитывается.

2. Параметры функции `tsp`

cpp
int tsp(vector<vector<int>>& dist, int pos, int visited, vector<vector<int>>& dp)
- `dist`: матрица расстояний.
- `pos`: текущий город, в котором находится коммивояжер.
- `visited`: битовая маска, кодирующая, какие города уже посещены (бит 1 — посещён, 0 — нет).
- `dp`: таблица для мемоизации, чтобы не пересчитывать одинаковые состояния.

3. Условие завершения

cpp
if (visited == (1 << n) - 1)
    return dist[pos][0];
- Когда все города посещены (`visited` битами равны 1 для всех `n` городов), функция возвращает стоимость пути обратно в начальный город (номер 0), замыкая маршрут.

4. Меморизация результатов

cpp
if (dp[pos][visited] != -1)
    return dp[pos][visited];
- Если в таблице `dp` для текущего состояния уже есть ответ, возвращаем его.
- Это позволяет избежать повторных вычислений и существенно ускоряет программу.

5. Основной цикл перебора городов

cpp
int ans = INF;
for (int city = 0; city < n; city++) {
    if ((visited & (1 << city)) == 0 && dist[pos][city] != INF) {
        int newCost = dist[pos][city] + tsp(dist, city, visited | (1 << city), dp);
        ans = min(ans, newCost);
    }
}
- Перебираем все города `city`, которые ещё не посещены (проверка с помощью битовой маски).
- Проверяем, что путь существует (`dist[pos][city] != INF`).
- Вычисляем стоимость пути, добавляя расстояние до нового города и рекурсивно вызываем функцию с обновлённым `pos` и `visited`.
- Запоминаем минимальное значение `ans` среди всех вариантов.

6. Сохранение и возврат результата

cpp
return dp[pos][visited] = ans;
- Записываем найденный минимальный путь для текущего состояния в `dp`.
- Возвращаем его сверху по рекурсивному стеку.

7. Вызов функции с начальными параметрами в `main`

cpp
int n = dist.size();
vector<vector<int>> dp(n, vector<int>((1 << n), -1));
cout << "Минимальное расстояние: " << tsp(dist, 0, 1, dp) << endl;
`
- n — количество городов.
- Инициализируем dp размером n на 2^n, заполненный -1 (не вычисленные состояния).
- Запускаем tsp, начиная с города 0, считая, что город 0 уже посещён (`visited = 1` — бит 0 равен 1).


- Этот алгоритм перебирает все возможные маршруты (с учётом посещения каждого города ровно один раз)



реализация на java
import java.util.Arrays;

public class TSP {
    static final int INF = 999999;

    static int tsp(int[][] dist, int pos, int visited, int[][] dp) {
        int n = dist.length;
        if (visited == (1 << n) - 1)
            return dist[pos][0];

        if (dp[pos][visited] != -1)
            return dp[pos][visited];

        int ans = INF;
        for (int city = 0; city < n; city++) {
            if ((visited & (1 << city)) == 0 && dist[pos][city] != INF) {
                int newCost = dist[pos][city] + tsp(dist, city, visited | (1 << city), dp);
                ans = Math.min(ans, newCost);
            }
        }
        return dp[pos][visited] = ans;
    }

    public static void main(String[] args) {
        int[][] dist = {
            {INF, 10, 15, 20},
            {10, INF, 35, 25},
            {15, 35, INF, 30},
            {20, 25, 30, INF}
        };
        int n = dist.length;
        int[][] dp = new int[n][1 << n];
        for (int[] row : dp)
            Arrays.fill(row, -1);

        System.out.println("Минимальное расстояние: " + tsp(dist, 0, 1, dp));
    }
}

объяснение реализации задачи коммивояжера на Java

 1. Константы и матрица расстояний

static final int INF = 999999;
- `INF — число, используемое для обозначения отсутствия прямого пути (или как бесконечность).

``java
int[][] dist = {
    {INF, 10, 15, 20},
    {10, INF, 35, 25},
    {15, 35, INF, 30},
    {20, 25, 30, INF}
};
- `dist` — матрица расстояний между четырьмя городами.
- Значение на `dist[i][j]` — расстояние от города `i` до города `j`.
- Диагональ заполнена `INF`, т.к. путь в тот же город не учитывается.

2. Параметры функции `tsp`

java
static int tsp(int[][] dist, int pos, int visited, int[][] dp)
- `dist`: матрица расстояний.
- `pos`: текущий город, где находится коммивояжер.
- `visited`: битовая маска для последовательности посещённых городов (бит равен 1, если город посещён).
- `dp`: таблица мемоизации для запоминания промежуточных результатов.

3. Условие завершения рекурсии

java
if (visited == (1 << n) - 1)
    return dist[pos][0];
- Если все города посещены (все биты в `visited` равны 1), возвращается расстояние назад в начальный город (0).
- Это замыкает цикл маршрута.

4. Использование мемоизации

java
if (dp[pos][visited] != -1)
    return dp[pos][visited];
- Если ранее для позиции `pos` и множества посещённых городов `visited` найдено минимальное расстояние, возвращаем его.
- Это снижает время работы, избегая повторных вычислений.

5. Перебор вариантов следующего города

java
int ans = INF;
for (int city = 0; city < n; city++) {
    if ((visited & (1 << city)) == 0 && dist[pos][city] != INF) {
        int newCost = dist[pos][city] + tsp(dist, city, visited | (1 << city), dp);
        ans = Math.min(ans, newCost);
    }
}
- Для каждого города `city` проверяется, посещён ли он (проверка бита в `visited`).
- Если город не посещён, и до него есть путь, считается стоимость перехода (`dist[pos][city]`) + оптимальный маршрут из нового города.
- Выбирается минимальное значение среди всех вариантов.

6. Сохранение результата и возврат

java
return dp[pos][visited] = ans;
- Результат запоминается в `dp` для оптимизации последующих вызовов.

7. Инициализация и запуск в `main`

java
int n = dist.length;
int[][] dp = new int[n][1 << n];
for (int[] row : dp)
    Arrays.fill(row, -1);

System.out.println("Минимальное расстояние: " + tsp(dist, 0, 1, dp));
`
- Создаётся таблица dp размером n на 2^n, заполненная -1 для указания на невычисленные состояния.
- Запускается tsp с начальным городом 0, считающимся уже посещённым (`visited = 1` — в двоичной форме `0001`).


- Программа проверяет все возможные обходы городов с помощью эффективного запоминания результатов, чтобы избежать экспоненциального перебора.
- Битовое представление множества посещённых городов позволяет компактно хранить информацию о состоянии.
- По окончании выводится минимальная сумма расстояний, позволяющая пройти все города и вернуться в исходный.
